# ğŸ›¡ï¸ Automating CVE Scanning in CI/CD: Make Your Builds Fail for the Right Reasons  

**_A practical guide to Trivy/Grype in GitHub Actions and GitLab CI with sane severity thresholds._**

---

> â€œIn high-performing organizations, everyone within the team shares a common goal â€” quality, availability, and security arenâ€™t the responsibility of individual departments, but are a part of everyoneâ€™s job, every day.â€  
> â€” *Gene Kim, The DevOps Handbook*

---

## ğŸ§  Why Failing the Build Is Healthy (Signal vs. Noise)

Breaking a build because of a security issue isnâ€™t failure â€” itâ€™s feedback.

Modern CI/CD isnâ€™t just about continuous integration or delivery anymore. Itâ€™s about **continuous validation** â€” ensuring that every merge produces not only a working artifact but also a **secure** one.

NaÃ¯ve CVE scanning often creates **noise**: hundreds of â€œmediumâ€ vulnerabilities that may not even be exploitable. The goal isnâ€™t to fail every build â€” itâ€™s to **fail for the right reasons**.

A healthy approach includes:  
- **Clear severity thresholds** (fail only on *High* and *Critical* CVEs).  
- **Ignore lists** for false positives or accepted risks.  
- **Detailed reports as artifacts** for triage rather than immediate blocking.  

Failing fast is valuable â€” but only when your failures are **meaningful**.

---

## âš™ï¸ GitHub Actions YAML (Matrix, Cache, SBOM)

Hereâ€™s a production-ready configuration for **Trivy** in GitHub Actions, built to ensure fast and consistent security scans that never rely on outdated vulnerability data.

The key principle is simple: **cache smartly, not blindly**.  
The Trivy database is updated daily and independent of your source code, so caching should help **accelerate updates**, not freeze them.

According to [Trivyâ€™s documentation](https://trivy.dev/docs/latest/configuration/db/#database-update-behavior), when a local database already exists, Trivy automatically downloads only the differences â€” keeping scans current while minimizing bandwidth use.

```yaml
name: CVE Scan
on: [push, pull_request]

jobs:
  trivy-scan:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        target: [go, docker]

    steps:
      - uses: actions/checkout@v4

      # 1) Restore vulnerability database cache
      - name: Cache Trivy database
        uses: actions/cache@v4
        with:
          path: ./.cache/trivy
          key: ${{ runner.os }}-trivy-db-${{ github.run_id }}
          restore-keys: |
            ${{ runner.os }}-trivy-db-
          # Each run creates a unique key but can restore the most recent cache
          # Trivy then performs incremental updates for the newest CVEs

      # 2) Install Trivy
      - name: Setup Trivy
        uses: aquasecurity/setup-trivy@v0.2.3
        with:
          version: v0.65.0
          cache: true

      # 3) Update Trivy databases (incremental if cache restored)
      - name: Update Trivy databases
        run: |
          echo "ğŸ“¥ Updating Trivy databases..."
          trivy image --download-db-only
          trivy image --download-java-db-only
          echo "âœ… Database is up to date."
```

The two commands update different internal databases that Trivy relies on:  
- `--download-db-only` fetches the **main vulnerability database**, which includes CVE data for OS packages, libraries, and container images.  
- `--download-java-db-only` updates the **Java-specific vulnerability database**, containing metadata for Maven artifacts and Java dependencies.  

Running both ensures that Trivy can detect vulnerabilities across **all dependency types**, whether they come from the base image, OS packages, or application-level components like JARs and WARs.  
This becomes essential in **mixed environments**, such as Go or Node.js services built atop Java-based base images or JVM tooling.

---

```yaml
      # 4) Prepare Docker image (build or pull)
      - name: Prepare Docker image
        if: matrix.target == 'docker'
        run: |
          IMAGE_NAME=myapp:latest
          if docker image inspect $IMAGE_NAME > /dev/null 2>&1; then
            echo "Image already exists locally."
          else
            echo "Building or pulling image..."
            docker build -t $IMAGE_NAME .
            # Or pull from registry:
            # docker pull ghcr.io/your-org/myapp:latest
          fi

      # 5) Run Trivy scan (uses updated DB)
      - name: Run Trivy Scan
        run: |
          echo "ğŸ” Running Trivy scan for ${{ matrix.target }}"
          if [ "${{ matrix.target }}" = "docker" ]; then
            trivy image \
              --severity HIGH,CRITICAL \
              --exit-code 1 \
              myapp:latest
          else
            trivy fs\
              --severity HIGH,CRITICAL \
              --exit-code 1 \
              .
          fi

      # 6) Generate SBOM for visibility and compliance
      - name: Generate SBOM
        if: always()
        run: |
          echo "ğŸ“‹ Generating SBOM..."
          if [ "${{ matrix.target }}" = "docker" ]; then
            trivy image \
              --format cyclonedx \
              --output sbom-docker.json \
              myapp:latest
          else
            trivy fs
              --format cyclonedx \
              --output sbom-filesystem.json \
              .
          fi
          echo "âœ… SBOM generated successfully."
```

---

### ğŸ” Filesystem vs. Docker Scans

This workflow runs Trivy in **two modes**, covering both your source code and your container image:

- `trivy fs` scans the **filesystem**, detecting vulnerabilities in your projectâ€™s dependencies (Go modules, npm packages, OS libraries, etc.).  
- `trivy image` scans the **Docker image**, detecting vulnerabilities introduced by the base image and system packages (e.g., Alpine, Debian).  

Running both ensures **full coverage** â€” you catch vulnerabilities both **before** building the image and **after** packaging your software.

---

### âœ… Why This Configuration Works

- **Always up-to-date:** Trivy downloads only incremental differences, ensuring the latest CVEs are detected every run.  
- **No stale cache:** Each pipeline run updates the database while reusing the previous cache for speed.  
- **No skip flags:** Avoids `--skip-db-update`, which would freeze the database and miss new vulnerabilities.  
- **Fast execution:** After the first run, incremental updates are small (5â€“10 MB) and complete in seconds.  
- **Full visibility:** Automatically generates an **SBOM** for compliance and supply chain transparency.

---

## ğŸ§¾ GitLab CI YAML + Report Artifacts  

GitLab offers native integration for Trivy, allowing results to appear directly in Merge Requests or the Security Dashboard â€” depending on your plan and scan type.

### Filesystem Scan (source code)

Generates a **Code Quality Report** visible in all GitLab tiers.

```yaml
trivy_filesystem_scan:
  image: aquasec/trivy:latest
  stage: test
  variables:
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
  before_script:
    - trivy image --download-db-only
  script:
    - trivy fs \
      --scanners vuln \
      --format template \
      --template "@/contrib/gitlab-codequality.tpl" \
      -o gl-codequality-report.json \
      .
  cache:
    key: trivy-db-$CI_COMMIT_REF_SLUG
    paths:
      - .trivycache/
  artifacts:
    reports:
      codequality: gl-codequality-report.json
    expire_in: 1 week
  allow_failure: true
  only:
    - merge_requests
    - main
```

### Container Image Scan (recommended for CVEs)

Generates a **Container Scanning Report**, compatible with GitLabâ€™s *Security Dashboard* (available in GitLab Ultimate).

```yaml
trivy_image_scan:
  image: aquasec/trivy:latest
  stage: security
  variables:
    TRIVY_NO_PROGRESS: "true"
    TRIVY_CACHE_DIR: ".trivycache/"
    IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  before_script:
    - trivy image --download-db-only
  script:
    - trivy image \
      --exit-code 0 \
      --format template \
      --template "@/contrib/gitlab.tpl" \
      -o gl-container-scanning-report.json \
      $IMAGE_TAG

    - trivy image \
      --exit-code 1 \
      --severity CRITICAL \
      $IMAGE_TAG
  cache:
    key: trivy-db-$CI_COMMIT_REF_SLUG
    paths:
      - .trivycache/
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
    expire_in: 1 week
  allow_failure: false
  only:
    - merge_requests
    - main
```

**Highlights:**  
- Proper report types (`codequality` and `container_scanning`).  
- Cached vulnerability DB for faster runs.  
- Updated templates aligned with GitLabâ€™s schema.  
- Granular control with `--severity` and `allow_failure`.  

---

## âš–ï¸ Trivy vs. Grype vs. Snyk: The Trade-offs  

**Trivy (Aqua Security)**  
Fast, open source, supports SBOMs, and integrates easily in CI. Ideal for **lightweight inline scanning**.

**Grype (Anchore)**  
Performs deeper image analysis and integrates with Syft. Slightly slower but provides **richer dependency insights**.

**Snyk**  
Cloud-based dashboards, license scanning, and fix suggestions. Proprietary, but powerful for **enterprise visibility**.

In short:  
If you value openness and speed â€” **Trivy** or **Grype**.  
If you need enterprise governance and dashboards â€” **Snyk**.

---

## ğŸ§  Visual Direction â€” Header Prompt  

> **Prompt for cover:**  
> â€œMinimalist header showing pipeline gears + shield icon + CVE tag.â€

Imagine a dark-themed header with CI/CD gears turning in the background and a glowing blue shield marked â€œCVE.â€  
It represents automation, protection, and trust â€” not panic.

---

## ğŸ Final Thoughts  

Automating CVE scanning shouldnâ€™t slow your pipeline â€” it should **strengthen** it.  
Security becomes part of the delivery rhythm when:  
- Builds fail for the right reasons.  
- Noise is controlled.  
- SBOMs are generated automatically.  

When your pipeline enforces security gates intelligently, youâ€™re not just shipping faster â€” youâ€™re shipping safer.

---

## ğŸ’¬ Join the Discussion  

Have you implemented automated CVE scanning in your pipelines?  
Which tools or thresholds worked best for your teams â€” and where did you find the balance between **security** and **speed**?

Join the conversation â€” thoughtful technical insights and real-world experiences are always welcome.  

ğŸ” CVE triage, DevSecOps practices, and vulnerability gating are complex topics that benefit from shared experience.  
Your perspective might help other engineers find the right balance between **speed and safety**.

If this article helped you, consider giving it a ğŸ‘ or sharing it with others working in **Go**, **DevOps**, and **secure software delivery**.  
Every bit of feedback helps improve the content â€” and strengthens our engineering community.  

---

**Originally published on Medium by Cassius Paim, Staff Engineer and Software Architect specializing in Go, Java and Kotlin.**

---

**ğŸ’¡ Tags:**  
#golang #devops #devsecops #cve #cicd
